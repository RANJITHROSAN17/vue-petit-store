(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["VuePetitStore"] = factory();
	else
		root["VuePetitStore"] = factory();
})(global, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.coffee");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/curtain.coffee":
/*!****************************!*\
  !*** ./src/curtain.coffee ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _;

_ = __webpack_require__(/*! lodash */ "lodash");
module.exports = {
  curtain: function (id) {
    var bottom_id, calc_id, left_id, right_id, space_id, spots_id, top_id;
    spots_id = `${id}_spots`;
    space_id = `${id}_space`;
    calc_id = `${id}_calc`;
    left_id = `${id}_left`;
    top_id = `${id}_top`;
    right_id = `${id}_right`;
    bottom_id = `${id}_bottom`;
    return {
      directives: {
        [id]: {
          bind: function (el, binding, {
            context
          }) {
            var base, vm;
            vm = context;

            if ((base = vm.$refs)[id] == null) {
              base[id] = [];
            }

            return vm.$refs[id].push(el);
          }
        }
      },
      data: function () {
        var bottom, left, right, top;
        left = top = -2e308;
        right = bottom = 2e308;
        return {
          [spots_id]: [],
          [id]: {
            left,
            top,
            right,
            bottom
          }
        };
      },
      computed: {
        [left_id]: function () {
          var i, len, o, ref, results;
          ref = this[spots_id];
          results = [];

          for (i = 0, len = ref.length; i < len; i++) {
            o = ref[i];
            results.push(o.left < this[id].left);
          }

          return results;
        },
        [top_id]: function () {
          var i, len, o, ref, results;
          ref = this[spots_id];
          results = [];

          for (i = 0, len = ref.length; i < len; i++) {
            o = ref[i];
            results.push(o.top < this[id].top);
          }

          return results;
        },
        [right_id]: function () {
          var i, len, o, ref, results;
          ref = this[spots_id];
          results = [];

          for (i = 0, len = ref.length; i < len; i++) {
            o = ref[i];
            results.push(this[id].right < o.right);
          }

          return results;
        },
        [bottom_id]: function () {
          var i, len, o, ref, results;
          ref = this[spots_id];
          results = [];

          for (i = 0, len = ref.length; i < len; i++) {
            o = ref[i];
            results.push(this[id].bottom < o.bottom);
          }

          return results;
        },
        [space_id]: function () {
          var enter, leave, move;

          enter = () => {
            return this[calc_id]();
          };

          leave = () => {
            var bottom, left, right, top;
            left = top = 0;
            right = bottom = 2e308;
            return this[id] = {
              left,
              top,
              right,
              bottom
            };
          };

          move = e => {
            var bottom, left, ref, ref1, ref2, ref3, ref4, ref5, right, top;
            left = right = (ref = e.pageX) != null ? ref : (ref1 = e.changedTouches) != null ? (ref2 = ref1[0]) != null ? ref2.pageX : void 0 : void 0;
            top = bottom = (ref3 = e.pageY) != null ? ref3 : (ref4 = e.changedTouches) != null ? (ref5 = ref4[0]) != null ? ref5.pageY : void 0 : void 0;
            return this[id] = {
              left,
              top,
              right,
              bottom
            };
          };

          return {
            scroll: enter,
            touchenter: enter,
            touchmove: move,
            touchleave: leave,
            mouseenter: enter,
            mousemove: move,
            mouseleave: leave
          };
        }
      },
      methods: {
        [calc_id]: function () {
          var bottom, left, list, o, oo, right, top;

          if (!(list = this.$refs[id])) {
            return;
          }

          return this[spots_id] = function () {
            var i, len, ref, results;
            results = [];

            for (i = 0, len = list.length; i < len; i++) {
              o = list[i];

              if (oo = (ref = o.getClientRects()) != null ? ref[0] : void 0) {
                ({
                  left,
                  top,
                  right,
                  bottom
                } = oo);
              } else {
                left = top = 2e308;
                right = bottom = 0;
              }

              results.push({
                left,
                top,
                right,
                bottom
              });
            }

            return results;
          }();
        }
      }
    };
  }
};

/***/ }),

/***/ "./src/device.coffee":
/*!***************************!*\
  !*** ./src/device.coffee ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var abg, abg_new, accel, accel_with_gravity, devicemotion, deviceorientation, geo, geo_to_s, geolocation, gravity, gyro, m, mks_to_s, rotate, scroll, scroll_poll, threshold_to_s, xyz, xyz_new;

geo_to_s = function (n, mark, minus) {
  var n1, n2, n3, n4, n5;
  n1 = parseInt(n);
  n2 = parseInt(n * 60 % 60);
  n3 = parseInt(n * 3600 % 60);
  n4 = parseInt(n * 216000 % 60);
  n5 = parseInt(n * 12960000 % 60);

  if (n < 0) {
    mark = minus;
  }

  return `${n1}°${n2}′${n3}″${n4}‴${n5}⁗${mark}`;
};

mks_to_s = function (n, mark) {
  var n1, n2;
  n1 = parseInt(n);
  n2 = parseInt(n * 100 % 100);
  return `${n1}${mark}${n2}c${mark}`;
};

threshold_to_s = function (newVal, margin, keep, lo, l1, l2, l3) {
  switch (false) {
    case !(newVal < -margin):
      return l1;

    case !(margin < newVal):
      return l3;

    case !(lo === l1 && newVal < -keep):
      return l1;

    case !(lo === l3 && keep < newVal):
      return l3;

    default:
      return l2;
  }
};

xyz = function (newVal, oldVal) {
  var keep, lx, ly, lz, margin, x, y, z;
  ({
    x,
    y,
    z
  } = newVal);
  ({
    margin,
    keep
  } = m);
  margin *= 10;
  keep *= 10;
  oldVal.label_x = lx = threshold_to_s(x, margin, keep, oldVal.label_x, "右", "", "左");
  oldVal.label_y = ly = threshold_to_s(y, margin, keep, oldVal.label_y, "上", "", "下");
  oldVal.label_z = lz = threshold_to_s(z, margin, keep, oldVal.label_z, "表", "", "裏");
  oldVal.label = `${lx}${ly}${lz}`;
  oldVal.x = x;
  oldVal.y = y;
  return oldVal.z = z;
};

abg = function (newVal, oldVal) {
  var alpha, beta, gamma, keep, la, lb, lg, margin;
  ({
    alpha,
    beta,
    gamma
  } = newVal);
  ({
    margin,
    keep
  } = m);
  margin *= 360;
  keep *= 360;
  oldVal.label_alpha = la = threshold_to_s(alpha, margin, keep, oldVal.label_alpha, "押下", "", "引上");
  oldVal.label_beta = lb = threshold_to_s(beta, margin, keep, oldVal.label_beta, "左巻", "", "右巻");
  oldVal.label_gamma = lg = threshold_to_s(gamma, margin, keep, oldVal.label_gamma, "右折", "", "左折");
  oldVal.label = `${la}${lb}${lg}`;
  oldVal.alpha = alpha;
  oldVal.beta = beta;
  return oldVal.gamma = gamma;
};

xyz_new = function () {
  return {
    x: 0,
    y: 0,
    z: 0,
    label: "",
    label_x: "",
    label_y: "",
    label_z: ""
  };
};

abg_new = function () {
  return {
    alpha: 0,
    beta: 0,
    gamma: 0,
    absolute: 0,
    label: "",
    label_alpha: "",
    label_beta: "",
    label_gamma: ""
  };
};

accel = xyz_new();
gravity = xyz_new();
accel_with_gravity = xyz_new();
gyro = abg_new();
rotate = abg_new();
geo = {
  label: "",
  latitude: 0,
  longitude: 0,
  altitude: 0,
  heading: 0,
  speed: 0
};
scroll = {
  top: 0,
  center: 0,
  bottom: 0,
  left: 0,
  right: 0,
  horizon: 0,
  height: 0,
  width: 0,
  size: 0,
  aspect_ratio: 1,
  is_square: true,
  is_oblong: false,
  is_horizontal: true,
  is_vertical: false
};
deviceorientation = {
  count: 0,
  call: function ({
    alpha,
    beta,
    gamma,
    absolute
  }) {
    gyro.alpha = alpha;
    gyro.beta = beta;
    gyro.gamma = gamma;
    return gyro.absolute = absolute;
  },
  with: function (o) {
    return Object.assign(o, {
      mounted: () => {
        if (typeof window === "undefined" || window === null) {
          return;
        }

        if (this.count++) {
          return;
        }

        return window.addEventListener("deviceorientation", this.call);
      },
      beforeDestroy: () => {
        if (--this.count) {
          return;
        }

        return window.removeEventListener("deviceorientation", this.call);
      }
    });
  }
};
devicemotion = {
  count: 0,
  call: function ({
    interval,
    acceleration,
    accelerationIncludingGravity,
    rotationRate
  }) {
    var calc_gravity;
    calc_gravity = {
      x: accelerationIncludingGravity.x - acceleration.x,
      y: accelerationIncludingGravity.y - acceleration.y,
      z: accelerationIncludingGravity.z - acceleration.z
    };
    xyz(acceleration, accel);
    xyz(accelerationIncludingGravity, accel_with_gravity);
    xyz(calc_gravity, gravity);
    return abg(rotationRate, rotate);
  },
  with: function (o) {
    return Object.assign(o, {
      mounted: () => {
        if (typeof window === "undefined" || window === null) {
          return;
        }

        if (this.count++) {
          return;
        }

        return window.addEventListener("devicemotion", this.call);
      },
      beforeDestroy: () => {
        if (--this.count) {
          return;
        }

        return window.removeEventListener("devicemotion", this.call);
      }
    });
  }
};
geolocation = {
  watch_id: null,
  count: 0,
  call: function ({
    coords,
    timestamp
  }) {
    var accuracy, altitude, altitudeAccuracy, heading, latitude, longitude, speed;
    ({
      accuracy,
      altitudeAccuracy,
      latitude,
      longitude,
      altitude,
      heading,
      speed
    } = coords);

    if (altitude == null) {
      altitude = 0;
    }

    geo.label = `${geo_to_s(longitude, 'N', 'S')} ${geo_to_s(latitude, 'E', 'W')} ${mks_to_s(altitude, 'm')}`;
    geo.longitude = longitude;
    geo.latitude = latitude;
    geo.altitude = altitude;
    geo.heading = heading;
    return geo.speed = speed;
  },
  with: function (o) {
    return Object.assign(o, {
      mounted: () => {
        if ((typeof navigator !== "undefined" && navigator !== null ? navigator.geolocation : void 0) == null) {
          return;
        }

        if (this.count++) {
          return;
        }

        return this.watch_id = navigator.geolocation.watchPosition(this.call, function ({
          code
        }) {
          return console.log(`watchPosition error = ${code}`);
        }, {
          enableHighAccuracy: true,
          maximumAge: 60 * 1000,
          timeout: 10 * 1000
        });
      },
      beforeDestroy: () => {
        if (--this.count) {
          return;
        }

        return navigator.geolocation.clearWatch(this.watch_id);
      }
    });
  }
};
scroll_poll = {
  count: 0,
  call: function () {
    var height, left, top, width;
    scroll.top = parseInt(scrollY);
    scroll.left = parseInt(scrollX);
    scroll.width = parseInt(innerWidth);
    scroll.height = parseInt(innerHeight);
    ({
      height,
      top,
      left,
      width
    } = scroll);

    if (width < height) {
      scroll.size = width;
      scroll.aspect_ratio = height / width;
      scroll.is_vertical = true;
      scroll.is_horizontal = false;
    } else {
      scroll.size = height;
      scroll.aspect_ratio = width / height;
      scroll.is_vertical = false;
      scroll.is_horizontal = true;
    }

    scroll.is_square = !(scroll.is_oblong = 1.35 < scroll.aspect_ratio);
    scroll.horizon = height >> 1;
    scroll.center = top + (height >> 1);
    scroll.bottom = top + height;
    scroll.right = left + width;
    return requestAnimationFrame(scroll_poll.call);
  },
  with: function (o) {
    return Object.assign(o, {
      mounted: () => {
        if (typeof window === "undefined" || window === null) {
          return;
        }

        if (this.count++) {
          return;
        }

        return this.call();
      },
      beforeDestroy: () => {}
    });
  }
};
module.exports = m = {
  margin: 0.4,
  keep: 0.1,
  device: function ({
    margin,
    keep
  }) {
    m.margin = margin;
    return m.keep = keep;
  },
  geo: function () {
    return geolocation.with({
      data: function () {
        return {
          geo
        };
      }
    });
  },
  gyro: function () {
    return deviceorientation.with({
      data: function () {
        return {
          gyro
        };
      }
    });
  },
  accel: function () {
    return devicemotion.with({
      data: function () {
        return {
          accel,
          gravity,
          accel_with_gravity
        };
      }
    });
  },
  rotate: function () {
    return devicemotion.with({
      data: function () {
        return {
          rotate
        };
      }
    });
  },
  scroll: function () {
    return scroll_poll.with({
      data: function () {
        return {
          scroll
        };
      },
      methods: {
        scroll_to: function ({
          query,
          mode
        }) {
          var el, height, top;

          if (!(el = typeof document !== "undefined" && document !== null ? document.querySelector(query) : void 0)) {
            return;
          }

          if (!({
            height,
            top
          } = el.getBoundingClientRect())) {
            return;
          }

          switch (mode) {
            case 'center':
              top += (height >> 1) - scroll.horizon;
              break;

            case 'bottom':
              top += height;
          }

          console.log(` go to ${query}(${mode}) as ${top}px`);
          return window.scrollBy(0, top);
        }
      }
    });
  }
};

/***/ }),

/***/ "./src/firebase.coffee":
/*!*****************************!*\
  !*** ./src/firebase.coffee ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var FirestoreQueryProxy, Mem, copy_to_str, firebase, firestore, firestore_base, joinSnapshot, m;
Mem = __webpack_require__(/*! memory-orm */ "memory-orm");

if (typeof window !== "undefined" && window !== null) {
  firebase = __webpack_require__(/*! firebase/app */ "firebase/app");

  __webpack_require__(/*! firebase/firestore */ "firebase/firestore");
}

firestore = function () {
  var store;
  store = firebase.firestore();
  store.settings({});
  return store;
};

copy_to_str = function (key) {
  return function (...args) {
    var arg, i, len;
    this.str += ` ${key}:`;

    for (i = 0, len = args.length; i < len; i++) {
      arg = args[i];
      this.str += arg;
      this.str += ":";
    }

    this.ref = this.ref[key](...args);
    return this;
  };
};

FirestoreQueryProxy = function () {
  class FirestoreQueryProxy {
    constructor(str, ref) {
      this.str = str;
      this.ref = ref;
    }

  }

  ;
  FirestoreQueryProxy.prototype.orderBy = copy_to_str("orderBy");
  FirestoreQueryProxy.prototype.limit = copy_to_str("limit");
  FirestoreQueryProxy.prototype.where = copy_to_str("where");
  return FirestoreQueryProxy;
}.call(undefined);

joinSnapshot = function (target, shot) {
  var eject;

  eject = function () {};

  return function (gate) {
    eject();
    return eject = gate && this[target] ? (console.log("join", gate), this[target].onSnapshot(shot.bind(this), function (err) {
      return console.error(err);
    })) : function () {};
  };
};

firestore_base = function (id, path, querys, {
  del,
  add,
  snap,
  shot
}) {
  var add_id, computed, default_id, del_id, join, join_id, joins, path_id, snap_id, watch;
  default_id = `${id}_default`;
  join_id = `${id}_join`;
  snap_id = `${id}_snap`;
  path_id = `${id}_path`;
  add_id = `${id}_add`;
  del_id = `${id}_del`;
  joins = [];
  watch = {};
  computed = {
    _firestore: firestore,
    [path_id]: path,
    [snap_id]: function () {
      if (this[path_id]) {
        return snap.call(this, this[path_id]);
      }
    }
  };

  if (querys != null ? querys.length : void 0) {
    querys.forEach(function (query, idx) {
      var join, query_id, ref_id, str_id;
      query_id = `${id}_query_${idx}_query`;
      ref_id = `${id}_query_${idx}_ref`;
      str_id = `${id}_query_${idx}_str`;

      computed[ref_id] = function () {
        if (!this[path_id]) {
          return;
        }

        return query.call(this, new FirestoreQueryProxy(this[path_id], this[snap_id]));
      };

      computed[str_id] = function () {
        var ref;
        return (ref = this[ref_id]) != null ? ref.str : void 0;
      };

      computed[query_id] = function () {
        if (this[str_id]) {
          return this[ref_id].ref;
        }
      };

      join = joinSnapshot(query_id, shot);
      joins.push([join, str_id]);
      return watch[str_id] = join;
    });
  } else {
    join = joinSnapshot(snap_id, shot);
    joins.push([join, path_id]);
    watch[path_id] = join;
  }

  return {
    beforeDestroy: function () {
      var i, len, results;
      results = [];

      for (i = 0, len = joins.length; i < len; i++) {
        [join, join_id] = joins[i];
        results.push(join.call(this, void 0));
      }

      return results;
    },
    mounted: function () {
      var i, len, results;
      this[default_id] = this[id];
      results = [];

      for (i = 0, len = joins.length; i < len; i++) {
        [join, join_id] = joins[i];
        results.push(join.call(this, this[join_id]));
      }

      return results;
    },
    methods: {
      [add_id]: add,
      [del_id]: del
    },
    computed: computed,
    watch: watch
  };
};

module.exports = m = {
  firestore_models: function (id, path, ...querys) {
    var set_key, snap_id;
    snap_id = `${id}_snap`;
    set_key = id.slice(0, -1);
    return firestore_base(id, path, querys, {
      del: function (_id) {
        var ref;

        if (!_id) {
          return;
        }

        return (ref = this[snap_id]) != null ? ref.doc(_id).delete() : void 0;
      },
      add: function (doc) {
        var _id, ref;

        ({
          _id
        } = doc);

        if (!_id) {
          return;
        }

        return (ref = this[snap_id]) != null ? ref.doc(_id).set(doc, {
          merge: true
        }) : void 0;
      },
      snap: function (path) {
        return this._firestore.collection(path);
      },
      shot: function (qs) {
        return qs.docChanges().forEach(({
          newIndex,
          oldIndex,
          type,
          doc
        }) => {
          switch (type) {
            case 'added':
            case 'modified':
              return Mem.Set[set_key].add(doc.data());

            case 'removed':
              return Mem.Set[set_key].remove(doc.id);
          }
        });
      }
    });
  },
  firestore_model: function (id, path) {
    var set_key, snap_id;
    snap_id = `${id}_snap`;
    set_key = id;
    return firestore_base(id, path, null, {
      del: function () {
        var ref;
        return (ref = this[snap_id]) != null ? ref.delete() : void 0;
      },
      add: function (doc) {
        var ref;
        return (ref = this[snap_id]) != null ? ref.set(doc, {
          merge: true
        }) : void 0;
      },
      snap: function (path) {
        return this._firestore.doc(path);
      },
      shot: function (doc) {
        var o;

        if (o = doc.data()) {
          return Mem.Set[set_key].add(o);
        } else {
          return Mem.Set[set_key].remove(doc.id);
        }
      }
    });
  },
  firestore_collection: function (id, path, ...querys) {
    var snap_id;
    snap_id = `${id}_snap`;
    return firestore_base(id, path, querys, {
      del: function (_id) {
        var ref;

        if (!_id) {
          return;
        }

        return (ref = this[snap_id]) != null ? ref.doc(_id).delete() : void 0;
      },
      add: function (doc) {
        var _id, ref;

        ({
          _id
        } = doc);

        if (!_id) {
          return;
        }

        return (ref = this[snap_id]) != null ? ref.doc(_id).set(doc, {
          merge: true
        }) : void 0;
      },
      snap: function (path) {
        return this._firestore.collection(path);
      },
      shot: function (qs) {
        return qs.docChanges().forEach(({
          newIndex,
          oldIndex,
          type,
          doc
        }) => {
          switch (type) {
            case 'added':
            case 'modified':
              return this[id][doc.id] = doc.data();

            case 'removed':
              return delete this[id][doc.id];
          }
        });
      }
    });
  },
  firestore_doc: function (id, path) {
    var default_id, snap_id;
    snap_id = `${id}_snap`;
    default_id = `${id}_default`;
    return firestore_base(id, path, null, {
      del: function () {
        var ref;
        return (ref = this[snap_id]) != null ? ref.delete() : void 0;
      },
      add: function (doc) {
        var ref;
        return (ref = this[snap_id]) != null ? ref.set(doc, {
          merge: true
        }) : void 0;
      },
      snap: function (path) {
        return this._firestore.doc(path);
      },
      shot: function (doc) {
        return this[id] = doc.exists ? doc.data() : this[default_id];
      }
    });
  }
};

/***/ }),

/***/ "./src/index.coffee":
/*!**************************!*\
  !*** ./src/index.coffee ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = { ...__webpack_require__(/*! ./time */ "./src/time.coffee"),
  ...__webpack_require__(/*! ./struct */ "./src/struct.coffee"),
  ...__webpack_require__(/*! ./timer */ "./src/timer.coffee"),
  ...__webpack_require__(/*! ./uri */ "./src/uri.coffee"),
  ...__webpack_require__(/*! ./curtain */ "./src/curtain.coffee"),
  ...__webpack_require__(/*! ./observer */ "./src/observer.coffee"),
  ...__webpack_require__(/*! ./storage */ "./src/storage.coffee"),
  ...__webpack_require__(/*! ./firebase */ "./src/firebase.coffee"),
  ...__webpack_require__(/*! ./device */ "./src/device.coffee"),
  ...__webpack_require__(/*! ./poll */ "./src/poll.coffee"),
  ...__webpack_require__(/*! ./path */ "./src/path.coffee"),
  ...__webpack_require__(/*! ./vue */ "./src/vue.coffee")
};

/***/ }),

/***/ "./src/observer.coffee":
/*!*****************************!*\
  !*** ./src/observer.coffee ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _, intersectionBase, resize_observer;

_ = __webpack_require__(/*! lodash */ "lodash");

intersectionBase = function (option) {
  var observer;
  observer = typeof IntersectionObserver !== "undefined" && IntersectionObserver !== null ? new IntersectionObserver(function (doms) {
    return doms.forEach(function (o) {
      return o.target._cb_intersection({
        is_hit: o.isIntersecting,
        ratio: o.intersectionRatio,
        cross: o.intersectionRect,
        bound: o.boundingClientRect,
        root: o.rootBounds
      });
    });
  }, option) : {
    observe: function () {},
    unobserve: function () {},
    disconnect: function () {}
  };
  return function (id) {
    var default_id;
    default_id = `${id}_default`;
    return {
      bind: function (el, binding, {
        context
      }) {
        var vm;
        vm = context;
        vm[default_id] = _.get(vm, id);
        return _.set(vm, id, null);
      },
      // vm[type_id] = types[vm[default_id].constructor]
      inserted: function (el, binding, {
        context
      }) {
        var cb;

        cb = function (o) {
          return _.set(this, id, o.is_hit ? this[default_id] : null);
        };

        el._cb_intersection = cb.bind(context);
        return observer.observe(el);
      },
      unbind: function (el) {
        return observer.unobserve(el);
      }
    };
  };
}; // observer.disconnect


resize_observer = typeof ResizeObserver !== "undefined" && ResizeObserver !== null ? new ResizeObserver(function (doms) {
  return doms.forEach(function (o) {
    var height, width;
    ({
      width,
      height
    } = o.contentRect);
    width = parseInt(width);
    height = parseInt(height);
    return o.target._cb_resize({
      width,
      height
    });
  });
}) : {
  observe: function () {},
  unobserve: function () {},
  disconnect: function () {}
};
module.exports = {
  resize: function (id) {
    var default_id, observer, type_id;
    default_id = `${id}_default`;
    type_id = `${id}_type`;
    observer = resize_observer;
    return {
      bind: function (el, binding, {
        context
      }) {
        var vm;
        vm = context;
        return vm[default_id] = _.get(vm, id);
      },
      // vm[type_id] = types[vm[default_id].constructor]
      inserted: function (el, binding, {
        context
      }) {
        var cb;

        cb = function (size) {
          return _.set(this, id, size);
        };

        el._cb_resize = cb.bind(context);
        return observer.observe(el);
      },
      unbind: function (el) {
        observer.unobserve(el);
        return observer.disconnect(el);
      }
    };
  },
  on_horizon: intersectionBase({
    root: null,
    rootMargin: '-50% 0% -50% 0%',
    threshold: [0]
  }),
  on_peek: intersectionBase({
    root: null,
    rootMargin: '25%',
    threshold: [0]
  }),
  on_appear: intersectionBase({
    root: null,
    rootMargin: '0%',
    threshold: [0.5]
  })
};

/***/ }),

/***/ "./src/path.coffee":
/*!*************************!*\
  !*** ./src/path.coffee ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Query, m;
({
  Query
} = __webpack_require__(/*! memory-orm */ "memory-orm"));
module.exports = m = {
  path_by: function (idx = 'idx', keys) {
    var computed, idx_a;
    idx_a = `${idx}_a`;
    computed = {};
    computed[idx_a] = {
      get: function () {
        return this[idx].split("-");
      }
    };
    keys.forEach(function (name, at) {
      var key, list;

      if (!name) {
        return;
      }

      key = `${name}_id`;
      list = `${name}s`;
      computed[key] = {
        get: function () {
          if (at < this[idx_a].length) {
            return this[idx_a].slice(0, +at + 1 || 9e9).join("-");
          }
        }
      };
      return computed[name] = {
        get: function () {
          return Query[list].find(this[key]);
        }
      };
    });
    return {
      computed
    };
  }
};

/***/ }),

/***/ "./src/poll.coffee":
/*!*************************!*\
  !*** ./src/poll.coffee ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var Mem,
    dexie,
    is_cache,
    is_online,
    is_visible,
    poll,
    poll_request,
    to_tempo,
    splice = [].splice;
Mem = __webpack_require__(/*! memory-orm */ "memory-orm");
dexie = null;

poll_request = function () {
  var Dexie;

  if (typeof document === "undefined" || document === null) {
    return;
  }

  Dexie = __webpack_require__(/*! dexie */ "dexie").default;
  dexie = new Dexie('poll-web');
  dexie.version(1).stores({
    meta: '&idx',
    data: '&idx'
  });
  return poll_request = function () {};
};

({
  to_tempo
} = __webpack_require__(/*! ./time */ "./src/time.coffee")); // has_last = {}

is_cache = {};
is_online = is_visible = false;

poll = function (cb) {
  return {
    mounted: function () {
      poll_request();
      this.timers = {};
      window.addEventListener('offline', this._waitwake);
      window.addEventListener('online', this._waitwake);
      document.addEventListener('visibilitychange', this._waitwake);
      return this._waitwake();
    },
    destroyed: function () {
      var key, ref, results, val;
      window.removeEventListener('offline', this._waitwake);
      window.removeEventListener('online', this._waitwake);
      document.removeEventListener('visibilitychange', this._waitwake);
      ref = this.timers;
      results = [];

      for (key in ref) {
        val = ref[key];
        results.push(clearTimeout(val));
      }

      return results;
    },
    methods: {
      get_by_network: function () {
        var key, list, ref, val;
        ref = this.timers;

        for (key in ref) {
          val = ref[key];
          clearTimeout(val);
        }

        list = cb.call(this);
        list.map(([name, id]) => {
          var idx;
          idx = [name, id].join("&");
          dexie.meta.delete(idx);
          dexie.data.delete(idx);
          return is_cache[idx] = 0;
        });
        return this._waitwake();
      },
      _waitwake: (() => {
        var _ref = _asyncToGenerator(function* () {
          var _this = this;

          var is_ok, key, list, ref, results, val;
          is_online = window.navigator.onLine;
          is_visible = 'hidden' !== document.visibilityState;
          is_ok = is_online && is_visible;

          if (is_ok) {
            list = cb.call(this);
            return yield Promise.all(list.map(function ([name, id]) {
              return _this.$store.dispatch(name, {
                id,
                name,
                timers: _this.timers
              });
            }));
          } else {
            ref = this.timers;
            results = [];

            for (key in ref) {
              val = ref[key];
              results.push(clearTimeout(val));
            }

            return results;
          }
        });

        return function _waitwake() {
          return _ref.apply(this, arguments);
        };
      })()
    }
  };
};

poll.cache = function (timestr = "10s", version = "1.0.0", vuex_id, cb) {
  // console.log { timestr, timeout, url: cb('*') }
  return function ({
    dispatch,
    state,
    commit,
    rootState
  }, {
    id,
    name,
    timers
  }) {
    var idx, roop, url;
    url = cb(id);
    idx = [name, id].join("&");

    roop = (() => {
      var _ref2 = _asyncToGenerator(function* () {
        var e, get_by_lf, get_by_network, get_pass, last_at, meta, next_at, timeout, write_at;
        ({
          last_at,
          write_at,
          next_at,
          timeout
        } = to_tempo(timestr));

        get_pass = function () {
          var wait;
          wait = new Date() - write_at;
          return console.log({
            timestr,
            idx,
            wait,
            url: null
          });
        };

        get_by_lf = (() => {
          var _ref3 = _asyncToGenerator(function* () {
            var meta, wait;
            meta = yield dexie.data.get(idx);
            Mem.State.store(meta);
            wait = new Date() - write_at;
            return console.log({
              timestr,
              idx,
              wait,
              url: '(LF)'
            });
          });

          return function get_by_lf() {
            return _ref3.apply(this, arguments);
          };
        })();

        get_by_network = (() => {
          var _ref4 = _asyncToGenerator(function* () {
            var meta, wait;
            meta = yield poll._api[name](url, id);
            meta.idx = idx;
            yield dexie.data.put(meta);
            wait = new Date() - write_at;
            return console.log({
              timestr,
              idx,
              wait,
              url
            });
          });

          return function get_by_network() {
            return _ref4.apply(this, arguments);
          };
        })();

        try {
          if (write_at < is_cache[idx]) {
            get_pass();
          } else {
            // IndexedDB metadata not use if memory has past data, 
            if (!(0 < is_cache[idx])) {
              meta = yield dexie.meta.get(idx);

              if ((meta != null ? meta.version : void 0) !== version) {
                meta = null;
              }
            }

            switch (false) {
              case !(write_at < (meta != null ? meta.next_at : void 0)):
                yield get_by_lf();
                break;

              case !(0 < (meta != null ? meta.next_at : void 0)):
                yield get_by_lf();
                yield get_by_network();
                break;

              default:
                yield get_by_network();
                dexie.meta.put({
                  idx,
                  version,
                  next_at
                });
            }
          }

          is_cache[idx] = next_at;
        } catch (error) {
          e = error;
          console.error(e);
        }

        if (timeout < 0x7fffffff) {
          //  ほぼ25日
          return timers[url] = setTimeout(roop, timeout);
        }
      });

      return function roop() {
        return _ref2.apply(this, arguments);
      };
    })();

    return roop();
  };
};

poll.caches = function (...arg) {
  var actions, cb, key, ref, timestr, version;
  ref = arg, [...arg] = ref, [actions] = splice.call(arg, -1);
  [timestr, version] = arg;

  for (key in actions) {
    cb = actions[key];
    actions[key] = poll.cache(timestr, version, key, cb);
  }

  return actions;
};

poll._api = {
  fetch: (() => {
    var _ref5 = _asyncToGenerator(function* (url, cb) {
      var data, res;
      res = yield fetch(url);
      data = yield res.json();
      return Mem.State.transaction(function () {
        return cb(data);
      });
    });

    return function fetch(_x, _x2) {
      return _ref5.apply(this, arguments);
    };
  })()
};

poll.api = function (o) {
  return Object.assign(poll._api, o);
};

module.exports = {
  poll
};

/***/ }),

/***/ "./src/storage.coffee":
/*!****************************!*\
  !*** ./src/storage.coffee ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $cookie_storage, $local_storage, $session_storage, Cookie, _, capture, m, relative_to, types;

_ = __webpack_require__(/*! lodash */ "lodash");
Cookie = __webpack_require__(/*! tiny-cookie */ "tiny-cookie");
({
  types,
  relative_to
} = __webpack_require__(/*! ./struct */ "./src/struct.coffee"));
$session_storage = {};
$local_storage = {};
$cookie_storage = {};

capture = function (s, type, _default) {
  if (s != null) {
    return type.by_str(s);
  } else {
    return _default;
  }
};

module.exports = m = {
  sessionStorage: function (id) {
    var default_id, global_id, type_id;
    global_id = `$data.$session_storage.${id}`;
    default_id = `${id}_default`;
    type_id = `${id}_type`;

    if (!_.has($session_storage, id)) {
      _.set($session_storage, id, null);
    }

    return {
      data: function () {
        return {
          $session_storage
        };
      },
      created: function () {
        this[default_id] = _.get(this, id);
        return this[type_id] = types[this[default_id].constructor];
      },
      mounted: function () {
        var s, val;
        s = window.sessionStorage.getItem(id);
        val = capture(s, this[type_id], this[default_id]);

        _.set(this, id, val);

        return _.set($session_storage, id, val);
      },
      watch: {
        [global_id]: function (val) {
          return _.set(this, id, val);
        },
        [id]: function (val) {
          var s;

          _.set($session_storage, id, val);

          if (val != null) {
            s = this[type_id].to_str(val);
            return window.sessionStorage.setItem(id, s);
          } else {
            return window.sessionStorage.removeItem(id);
          }
        }
      }
    };
  },
  localStorage: function (id) {
    var default_id, global_id, handle_id, type_id;
    global_id = `$data.$local_storage.${id}`;
    default_id = `${id}_default`;
    handle_id = `${id}_handle`;
    type_id = `${id}_type`;

    if (!_.has($local_storage, id)) {
      _.set($local_storage, id, null);
    }

    return {
      data: function () {
        return {
          $local_storage
        };
      },
      created: function () {
        this[default_id] = _.get(this, id);
        return this[type_id] = types[this[default_id].constructor];
      },
      mounted: function () {
        var s, val;
        s = window.localStorage.getItem(id);
        val = capture(s, this[type_id], this[default_id]);

        _.set(this, id, val);

        _.set($local_storage, id, val);

        this[handle_id] = ({
          key,
          newValue
        }) => {
          if (key === id) {
            val = capture(newValue, this[type_id], this[default_id]);

            _.set(this, id, val);

            return _.set($local_storage, id, val);
          }
        };

        return window.addEventListener("storage", this[handle_id]);
      },
      beforeDestroy: function () {
        return window.removeEventListener("storage", this[handle_id]);
      },
      watch: {
        [global_id]: function (val) {
          return _.set(this, id, val);
        },
        [id]: function (val) {
          var s;

          _.set($local_storage, id, val);

          if (val != null) {
            s = this[type_id].to_str(val);
            return window.localStorage.setItem(id, s);
          } else {
            return window.localStorage.removeItem(id);
          }
        }
      }
    };
  },
  cookie: function (id, options = {
    expires: '1M'
  }) {
    var default_id, global_id, type_id;
    global_id = `$data.$cookie_storage.${id}`;
    default_id = `${id}_default`;
    type_id = `${id}_type`;

    if (!_.has($cookie_storage, id)) {
      _.set($cookie_storage, id, null);
    }

    return {
      data: function () {
        return {
          $cookie_storage
        };
      },
      created: function () {
        this[default_id] = _.get(this, id);
        return this[type_id] = types[this[default_id].constructor];
      },
      mounted: function () {
        var s, val;
        s = Cookie.get(id);
        val = capture(s, this[type_id], this[default_id]);

        _.set(this, id, val);

        return _.set($cookie_storage, id, val);
      },
      watch: {
        [global_id]: function (val) {
          return _.set(this, id, val);
        },
        [id]: function (val) {
          var s;

          _.set($cookie_storage, id, val);

          if (val != null) {
            s = this[type_id].to_str(val);
            return Cookie.set(id, s, options);
          } else {
            return Cookie.remove(id);
          }
        }
      }
    };
  }
};

/***/ }),

/***/ "./src/struct.coffee":
/*!***************************!*\
  !*** ./src/struct.coffee ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _, relative_to, simple_route, to_Array, to_Number, to_String, zero;

_ = __webpack_require__(/*! lodash */ "lodash");
zero = [null, void 0, "", 0 / 0];

simple_route = function (o) {
  var key, ref, val;
  ref = o.query;

  for (key in ref) {
    val = ref[key];

    if (zero.includes(val)) {
      delete o.query[key];
    }
  }

  return o;
};

relative_to = function ({
  name,
  params,
  query,
  hash
}, o, is_replace) {
  var key, tgt, to, val;

  if (!is_replace) {
    params = _.cloneDeep(params);
    query = _.cloneDeep(query);
  }

  to = {
    name,
    params,
    query,
    hash
  };

  for (key in o) {
    val = o[key];
    tgt = params.hasOwnProperty(key) ? params : query;
    tgt[key] = val;
  }

  return simple_route(to);
};

to_String = function (nil) {
  return function (u) {
    if (zero.includes(u)) {
      return nil;
    } else {
      return String(u);
    }
  };
};

to_Number = function (u) {
  if (zero.includes(u)) {
    return 0 / 0;
  } else {
    return Number(u);
  }
};

to_Array = function (u) {
  if (zero.includes(u)) {
    return [];
  } else {
    if (u instanceof Array) {
      return u;
    } else {
      return Array(u);
    }
  }
};

module.exports = {
  simple_route,
  relative_to,
  types: {
    [Number]: {
      to_str: to_String(""),
      by_str: to_Number,
      by_url: to_Number
    },
    [String]: {
      to_str: to_String(""),
      by_str: to_String(void 0),
      by_url: to_String("")
    },
    [Array]: {
      to_str: function (o) {
        return JSON.stringify(o) || [];
      },
      by_str: function (o) {
        return JSON.parse(o) || [];
      },
      by_url: to_Array
    },
    [Object]: {
      to_str: function (o) {
        return JSON.stringify(o) || {};
      },
      by_str: function (o) {
        return JSON.parse(o) || {};
      }
    }
  }
};

/***/ }),

/***/ "./src/time.coffee":
/*!*************************!*\
  !*** ./src/time.coffee ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var DAY,
    DISTANCES,
    DISTANCE_LONG_AGO,
    DISTANCE_NAN,
    HOUR,
    INTERVAL,
    MINUTE,
    MONTH,
    SECOND,
    TIMEZONE_OFFSET_JP,
    Tempo,
    VALID,
    WEEK,
    YEAR,
    m,
    timezone,
    to_msec,
    to_relative_time_distance,
    to_sec,
    to_tempo,
    to_tempo_bare,
    splice = [].splice;
Tempo = class Tempo {
  constructor(...args) {
    var callback, ref;
    ref = args, [...args] = ref, [callback] = splice.call(args, -1);
    this.args = args;
    this.callback = callback;
    this.tempo = to_tempo(this.args[0], "0s", new Date(0));
  }

  tick() {
    var tempo;
    tempo = to_tempo(...this.args);

    if (this.tempo.now_idx === tempo.now_idx) {
      return;
    }

    this.callback(tempo);
    return this.tempo = tempo;
  }

};

to_msec = function (str) {
  return 1000 * to_sec(str);
};

to_sec = function (str) {
  var timeout;
  timeout = 0;
  str.replace(/(\d+)(.)|0/g, function (_, num, unit) {
    if (!(num = Number(num))) {
      return null;
    }

    return timeout += function () {
      switch (unit) {
        case "s":
        case "秒":
          return num;

        case "m":
        case "分":
          return 60 * num;

        case "h":
        case "時":
          return 3600 * num;

        case "d":
        case "日":
          return 3600 * 24 * num;

        case "w":
        case "週":
          return 3600 * 24 * 7 * num;

        case "y":
        case "年":
          return 3600 * 24 * 365 * num;

        default:
          throw new Error(`${timestr} at ${num}${unit}`);
      }
    }();
  });
  return timeout;
};

to_relative_time_distance = function (msec) {
  var i, idx, len, limit;

  if (msec < -VALID || VALID < msec || msec - 0 === 0 / 0) {
    return DISTANCE_NAN;
  }

  for (idx = i = 0, len = DISTANCES.length; i < len; idx = ++i) {
    [limit] = DISTANCES[idx];

    if (msec < limit) {
      return DISTANCES[idx];
    }
  }

  return DISTANCE_LONG_AGO;
};

to_tempo = function (size, gap_str = "0s", write_at = new Date()) {
  var gap;
  size = to_msec(size);
  gap = to_msec(gap_str) + timezone;
  return to_tempo_bare(size, gap, write_at - 0);
};

to_tempo_bare = function (size, gap, write_at) {
  var last_at, next_at, now_idx, remain, since, timeout;
  now_idx = Math.floor((write_at - gap) / size);
  last_at = (now_idx + 0) * size + gap;
  next_at = (now_idx + 1) * size + gap;
  remain = next_at - write_at;
  since = write_at - last_at;
  timeout = remain;
  return {
    last_at,
    write_at,
    next_at,
    timeout,
    now_idx,
    timezone,
    remain,
    since,
    gap
  };
};

SECOND = to_msec("1s");
MINUTE = to_msec("1m");
HOUR = to_msec("1h");
DAY = to_msec("1d");
WEEK = to_msec("1w");
INTERVAL = 0x7fffffff; // 31bits.

MONTH = to_msec("30d");
YEAR = to_msec("1y");
VALID = 0xfffffffffffff; // 52 bits.

TIMEZONE_OFFSET_JP = to_msec("-9h");
timezone = typeof window !== "undefined" && window !== null ? MINUTE * new Date().getTimezoneOffset() : TIMEZONE_OFFSET_JP;
DISTANCES = [DISTANCE_NAN = [-VALID, INTERVAL, YEAR, "？？？"], [-YEAR, INTERVAL, YEAR, "%s年後"], [-MONTH, INTERVAL, MONTH, "%sヶ月後"], [-WEEK, WEEK, WEEK, "%s週間後"], [-DAY, DAY, DAY, "%s日後"], [-HOUR, HOUR, HOUR, "%s時間後"], [-MINUTE, MINUTE, MINUTE, "%s分後"], [-25000, SECOND, SECOND, "%s秒後"], [25000, 25000, 25000, "今"], [MINUTE, SECOND, SECOND, "%s秒前"], [HOUR, MINUTE, MINUTE, "%s分前"], [DAY, HOUR, HOUR, "%s時間前"], [WEEK, DAY, DAY, "%s日前"], [MONTH, WEEK, WEEK, "%s週間前"], [YEAR, INTERVAL, MONTH, "%sヶ月前"], [VALID, INTERVAL, YEAR, "%s年前"], DISTANCE_LONG_AGO = [2e308, INTERVAL, VALID, "昔"]];
module.exports = m = {
  Tempo,
  to_msec,
  to_sec,
  to_tempo,
  to_tempo_bare,
  to_relative_time_distance,
  timezone
};

/***/ }),

/***/ "./src/timer.coffee":
/*!**************************!*\
  !*** ./src/timer.coffee ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _, debounces, delays, relative, throttles, time_base, to_msec, to_relative_time_distance, to_tempo_bare;

_ = __webpack_require__(/*! lodash */ "lodash");
({
  to_msec,
  to_tempo_bare,
  to_relative_time_distance
} = __webpack_require__(/*! ./time */ "./src/time.coffee"));

time_base = function (method) {
  return function (id, {
    times
  }) {
    var default_id, tail_funcs, tail_ids;
    default_id = `${id}_default`;
    tail_ids = `${id}_tail_ids`;
    tail_funcs = `${id}_tail_funcs`;
    return {
      data: function () {
        var o;
        o = {};
        times.forEach(time => {
          var tail_id;
          tail_id = `${id}_${time}`;
          return _.set(o, tail_id, null);
        });
        return o;
      },
      created: function () {
        var id_value;
        this[tail_ids] = [];
        this[tail_funcs] = [];
        id_value = _.get(this, id);
        times.forEach(time => {
          var msec, tail_id;
          msec = to_msec(time);
          tail_id = `${id}_${time}`;

          _.set(this, tail_id, id_value);

          this[tail_ids].push(tail_id);
          return this[tail_funcs].push(method(value => {
            return _.set(this, tail_id, value);
          }, msec));
        });
        return this[default_id] = id_value;
      },
      watch: {
        [id]: function (newValue) {
          var i, idx, len, ref, results, tail_func;
          ref = this[tail_funcs];
          results = [];

          for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
            tail_func = ref[idx];
            results.push(tail_func(newValue));
          }

          return results;
        }
      }
    };
  };
};

debounces = time_base(_.debounce);
throttles = time_base(_.throttle);
delays = time_base(function (cb, msec) {
  return function (value) {
    return setTimeout(cb, msec, value);
  };
});

relative = function (id, {
  limit,
  format
} = {}) {
  var distance_id, interval_id, limit_id, msec_id, now_id, tempo_id, text_id, tick_id;
  now_id = `${id}_now`;
  msec_id = `${id}_msec`;
  tick_id = `${id}_tick`;
  text_id = `${id}_text`;
  limit_id = `${id}_limit`;
  tempo_id = `${id}_tempo`;
  distance_id = `${id}_distance`;
  interval_id = `${id}_interval`;
  return {
    data: function () {
      return {
        [now_id]: Date.now(),
        [limit_id]: to_msec(limit)
      };
    },
    computed: {
      [msec_id]: function () {
        return this[now_id] - new Date(this[id]).getTime();
      },
      [distance_id]: function () {
        return to_relative_time_distance(this[msec_id]);
      },
      [tempo_id]: function () {
        var interval;
        [_, interval] = this[distance_id];
        return to_tempo_bare(interval, 0, this[msec_id]);
      },
      [text_id]: function () {
        var limit_msec, msec, now_idx, text;
        msec = this[msec_id];
        limit_msec = this[limit_id];
        [,,, text] = this[distance_id];
        ({
          now_idx
        } = this[tempo_id]);

        if (limit_msec < msec) {
          clearInterval(this[interval_id]);
          this[interval_id] = null;
          return format(this[id]);
        }

        this[tick_id];

        if (msec < -limit_msec) {
          return format(this[id]);
        }

        return text.replace('%s', Math.abs(now_idx));
      },
      [tick_id]: function () {
        var timeout;
        ({
          timeout
        } = this[tempo_id]);

        if (this[interval_id]) {
          clearInterval(this[interval_id]);
        }

        this[interval_id] = setInterval(() => {
          this[now_id] = Date.now();
          return this[tick_id];
        }, timeout);
      }
    },
    beforeDestroy: function () {
      clearInterval(this[interval_id]);
      return this[interval_id] = null;
    }
  };
};

module.exports = {
  relative,
  delays,
  debounces,
  throttles
};

/***/ }),

/***/ "./src/uri.coffee":
/*!************************!*\
  !*** ./src/uri.coffee ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _, m, relative_to, routeBase, types, zero;

_ = __webpack_require__(/*! lodash */ "lodash");
({
  types,
  relative_to
} = __webpack_require__(/*! ./struct */ "./src/struct.coffee"));
zero = [null, void 0, "", 0 / 0];

routeBase = function (change_url) {
  return function (id) {
    var default_id, route_into, type_id;
    default_id = `${id}_default`;
    type_id = `${id}_type`;

    route_into = function (newRoute, oldRoute) {
      var s, val;
      s = newRoute.params[id] || newRoute.query[id];
      val = zero.includes(s) ? this[default_id] : this[type_id].by_url(s);
      return _.set(this, id, val);
    };

    return {
      created: function () {
        this[default_id] = _.get(this, id);
        return this[type_id] = types[this[default_id].constructor];
      },
      // for changed component.
      mounted: function () {
        var s, val;
        s = this.$route.params[id] || this.$route.query[id];

        if (!zero.includes(s)) {
          val = this[type_id].by_url(s);
          return _.set(this, id, val);
        }
      },
      // for same component but uri changed.
      beforeRouteEnter: function (newRoute, oldRoute, next) {
        return next(function (vm) {
          return route_into.call(vm, newRoute, oldRoute);
        });
      },
      // for same component but uri changed.
      beforeRouteUpdate: function (newRoute, oldRoute, next) {
        next();
        return route_into.call(this, newRoute, oldRoute);
      },
      watch: {
        [id]: function (newVal) {
          var href, location;
          ({
            location,
            href
          } = this.$router.resolve(relative_to(this.$route, {
            [id]: newVal
          }, true)));
          return change_url.call(this, href);
        }
      }
    };
  };
};

module.exports = m = {
  replaceState: routeBase(function (href) {
    return history.replaceState(null, null, href);
  }),
  pushState: routeBase(function (href) {
    return history.pushState(null, null, href);
  })
};

/***/ }),

/***/ "./src/vue.coffee":
/*!************************!*\
  !*** ./src/vue.coffee ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $shared_memory, _, m;

_ = __webpack_require__(/*! lodash */ "lodash");
$shared_memory = {};
module.exports = m = {
  share: function (id) {
    if ($shared_memory[id] == null) {
      $shared_memory[id] = null;
    }

    return {
      data: function () {
        return {
          $shared_memory
        };
      },
      computed: {
        [id]: {
          get: function () {
            return $shared_memory[id];
          },
          set: function (o) {
            return $shared_memory[id] = o;
          }
        }
      }
    };
  },
  vuex_read: function (id, opt) {
    var dir, getter;
    dir = (opt.on || "").split('.');
    getter = [...dir.slice(0), id].join('.');
    return {
      computed: {
        [id]: {
          get: function () {
            return _.get(this.$store.state, getter);
          }
        }
      }
    };
  },
  vuex: function (id, opt) {
    var dir, getter, mutation, setter;
    dir = (opt.on || "").split('.');
    mutation = [dir[0], 'update'].join('/');
    getter = [...dir.slice(0), id].join('.');
    setter = [...dir.slice(1), id].join('.');
    return {
      computed: {
        [id]: {
          get: function () {
            return _.get(this.$store.state, getter);
          },
          set: function (val) {
            var o;
            o = _.set({}, setter, val);
            return this.$store.commit(mutation, o);
          }
        }
      }
    };
  }
};

/***/ }),

/***/ "dexie":
/*!************************!*\
  !*** external "dexie" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("dexie");

/***/ }),

/***/ "firebase/app":
/*!*******************************!*\
  !*** external "firebase/app" ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("firebase/app");

/***/ }),

/***/ "firebase/firestore":
/*!*************************************!*\
  !*** external "firebase/firestore" ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("firebase/firestore");

/***/ }),

/***/ "lodash":
/*!*************************!*\
  !*** external "lodash" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("lodash");

/***/ }),

/***/ "memory-orm":
/*!*****************************!*\
  !*** external "memory-orm" ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("memory-orm");

/***/ }),

/***/ "tiny-cookie":
/*!******************************!*\
  !*** external "tiny-cookie" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("tiny-cookie");

/***/ })

/******/ });
});
//# sourceMappingURL=index.min.js.map